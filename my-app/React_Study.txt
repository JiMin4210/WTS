======================================================================================
React 컴포넌트 랜더링

솔직히 말씀드리면, 작은 앱에서는 useCallback 안 써도 체감이 안 됩니다. 컴퓨터가 워낙 빠르니까요.
하지만 다음 상황에서는 필수입니다:
자식 컴포넌트가 아주 복잡할 때: 다시 그리는 데 0.5초 걸리는 차트 같은 경우, 부모가 바뀔 때마다 차트가 번쩍거리면 사용자 경험이 최악이 됩니다.
무한 루프 방지: useEffect 안에서 그 함수를 쓸 때, 주소가 계속 바뀌면 useEffect가 무한 실행될 수 있습니다.

1. 성능 최적화 삼총사 개념 정리
useCallback, Memo, UseMemo
리액트는 기본적으로 "부모가 바뀌면 자식도 바꾼다"는 주의지만, 이 삼총사를 쓰면 "바뀐 게 없으면 재활용한다"로 전략을 바꿀 수 있습니다.
이 친구들은 보통 세트로 움직입니다. 하나만 쓰면 효과가 없거나 오히려 성능이 떨어질 수 있어요.
부모 컴포넌트 App이 있고, 최적화된 자식 Child가 있다고 가정해 봅시다.
 - React.memo만 썼을 때:
  - 부모가 자식에게 onClick={handleAction} 함수를 줍니다. 부모가 리렌더링될 때마다 handleAction 함수가 새로 만들어집니다. 자식은 memo를 썼음에도 불구하고 "어? 함수가 새 거네?" 하고 다시 그려집니다. (실패!)
 - React.memo + useCallback 같이 썼을 때:
  - 부모가 handleAction을 useCallback으로 감싸서 줍니다. 부모가 리렌더링되어도 함수 주소가 똑같습니다. 자식은 memo를 확인하고 "오, 함수 주소가 그대로네? 나 안 그려!" 하고 통과합니다. (성공!)

이름	      종류	     타겟 (무엇을 저장하나)	   한 줄 요약
React.memo	컴포넌트	 컴포넌트 자체	       "전달받은 Props가 안 변했으면 나(자식)는 안 그릴래!"
특징: 부모가 리렌더링되어도 name 값이 그대로라면 Child는 다시 그려지지 않습니다.

useMemo	    훅 (Hook)   함수의 결과값	      "복잡한 계산 결과값, 일단 메모해두고 재사용할래!"
특징: 영수증리스트가 바뀔 때만 다시 계산합니다. 그 외에 부모가 리렌더링될 때는 미리 계산해둔 숫자만 쏙 가져다 씁니다.

useCallback	훅 (Hook)	함수 자체	          "함수 모양(주소)을 박제해서 자식한테 똑같이 줄래!"
특징: 아까 배운 대로, 함수의 메모리 주소를 고정해서 React.memo를 쓴 자식이 오해하지 않게 합니다.

4. 실전 사용법 요약 (언제 뭘 쓸까?)
상황	사용 도구
"화면의 특정 부분이 너무 무거워서 부모랑 따로 놀게 하고 싶어"   그 컴포넌트를 React.memo로 감싸기
"데이터 목록을 필터링하거나 합계를 구하는 계산이 너무 무거워"	그 계산 값을 useMemo로 감싸기
React.memo를 쓴 자식에게 함수를 넘겨줘야 해"	            그 함수를 useCallback으로 감싸기
useEffect의 의존성 배열에 함수를 넣어야 해"	                그 함수를 useCallback으로 감싸기
======================================================================================
1. async function이란 무엇인가? (비동기의 마법)
리액트(자바스크립트)는 보통 한 번에 한 줄씩 코드를 실행합니다. 하지만 서버에서 데이터를 가져오는 일은 시간이 오래 걸리죠(0.5초~2초).
 - 일반 함수: 서버에 요청을 보내고 응답이 올 때까지 프로그램 전체가 멈춰버립니다. (화면 클릭도 안 됨)
 - async 함수: "나 이거 서버에서 가져올 건데, 시간이 좀 걸릴 것 같아. 그동안 넌 다른 일(화면 그리기 등) 하고 있어!"라고 말하는 비동기 함수입니다.
핵심 키워드
 - async: "이 함수 안에서는 기다려야 할 작업이 있어!"라고 선언하는 표식입니다.
 - await: "이 작업이 끝날 때까지 여기서 잠시 멈춰서 기다려줘."라는 뜻입니다.

======================================================================================
하위 컴포넌트 값 Props(프롭스) 전달
리액트에서 컴포넌트 태그 안에 이름={내용} 형태로 작성된 것들이 모두 하위 컴포넌트에게 전달되는 Props(프롭스)입니다. 하나씩 짚어드릴게요.

1. 데이터를 전달하는 코드 (값 전달)
 - 자식 컴포넌트가 화면을 그릴 수 있도록 정보를 넘겨주는 부분들입니다.
  - <Sidebar ... /> 에 전달:
   - open={sidebarOpen}: 사이드바가 열렸는지 닫혔는지 상태 전달.
   - devices={bootstrap.devices}: 전체 장치 리스트 전달.
   - selectedDeviceId={bootstrap.selectedDeviceId}: 지금 누가 선택됐는지 전달.
  - <TopBar ... /> 에 전달:
   - isLoggedIn={bootstrap.isLoggedIn}: 로그인 여부 전달.
   - me={bootstrap.me}: 내 정보(이름 등) 전달.
  - <SeriesChart ... /> 에 전달:
   - points={series.points}: 차트에 그릴 핵심 데이터 전달.
   - tab={tab}, dayDate={dayDate} 등: 현재 보고 있는 날짜 기준 전달.

2. 함수를 전달하는 코드 (동작 전달)
- 자식 컴포넌트에서 어떤 일이 일어났을 때(클릭 등), 부모의 상태를 바꿔달라고 요청하기 위해 함수를 넘겨주는 부분입니다.
  - <Sidebar ... /> 에 전달:
   - onSelectDevice={(id) => bootstrap.setSelectedDeviceId(id)}: 사이드바에서 장치를 클릭하면 부모의 selectedDeviceId를 바꿔라!
   - onRemoveDevice={(id) => bootstrap.removeDevice(id)}: 삭제 버튼 누르면 지워라!
  - <TopBar ... /> 에 전달:
   - onToggleSidebar={() => setSidebarOpen(...)}: 햄버거 버튼 누르면 사이드바 토글해라!
  - <Tabs ... /> 에 전달:
   - onChange={setTab}: 탭을 클릭하면 tab 상태를 바꿔라!

3. 우리가 공부한 useCallback과 연관된 부분은?
    질문하신 내용 중 "함수를 전달해주는 코드"가 바로 이 연관성의 핵심입니다.
    코드 중간에 있는 <button onClick={refreshDeviceAll}> 부분을 보세요.
    만약 이 버튼이 단순한 HTML 태그(button)가 아니라, <RefreshButton onRefresh={refreshDeviceAll} /> 라는 커스텀 컴포넌트였다면 어땠을까요?
    그러면 refreshDeviceAll 함수가 리렌더링 때마다 새로 만들어질 때, RefreshButton 컴포넌트도 아까 배운 이유로 인해 계속 다시 그려지게 됩니다.
    현재 코드의 특징:
    지금 이 코드에서는 refreshDeviceAll을 일반 HTML 버튼(button)에 직접 연결했습니다. 일반 HTML 태그는 리렌더링 성능 최적화 대상이 아니므로 여기서 useCallback을 안 쓴 건 아무 문제가 없습니다.
    하지만 <Sidebar />, <TopBar />, <SeriesChart /> 같은 친구들은 직접 만든 하위 컴포넌트들입니다.
    이 컴포넌트들 내부가 복잡하다면, 여기에 전달되는 onSelectDevice, onToggleSidebar 같은 함수들이 useCallback으로 감싸져 있어야 이 자식 컴포넌트들이 불필요하게 다시 그려지는 것을 막을 수 있습니다.

    refreshDeviceAll함수가 재생성(주소변경) 하는 조건이 내부 코드로 잇는 refresh의 주소가 바뀌면 이 함수가 재생성 돼?
      - 네, 맞습니다. refreshDeviceAll 함수 내부에서 사용하는 devLast.refresh나 series.refresh의 주소(참조값)가 바뀌면, 리액트는 이들을 포함하고 있는 부모 컴포넌트를 다시 그리면서 refreshDeviceAll 함수도 새로 만듭니다.
======================================================================================
전체적인 코드를 봤을 때 App(최상위 컴포넌트)은 리렌더링 하는 조건이 뭐야?

분석하신 코드를 바탕으로 App 컴포넌트가 다시 그려지는(리렌더링) 조건을 정리해 드릴게요. 리액트에서 부모가 다시 그려지려면 그가 가진 '상태(State)'나 '전대받은 값(Props)'이 변해야 합니다.
App 컴포넌트는 최상위이므로, 주로 내부에서 선언된 useState나 커스텀 훅들이 뱉어내는 값이 바뀔 때 리렌더링됩니다.

1. useState로 만든 상태들이 바뀔 때 (직접적 조건)
 - tab: 상단 탭(일/월/연)을 클릭하여 값이 바뀔 때 (setTab)
 - sidebarOpen: 사이드바를 열거나 닫을 때 (setSidebarOpen)
 - dayDate, monthYearMonth, year: 화살표 버튼(◀, ▶)을 눌러 날짜를 이동시킬 때 (setDayDate 등)
 - lastCheckedAt: 새로고침 버튼을 눌러 확인 시각이 업데이트될 때 (setLastCheckedAt)
 - autoCheckedFor: 장치가 변경되어 자동 조회가 완료되었을 때 (setAutoCheckedFor)

2. 커스텀 훅(useBootstrap, useSeries 등) 내부의 상태가 바뀔 때
 - App은 이 훅들을 구독하고 있기 때문에, 훅 내부에서 데이터가 변하면 App도 같이 리렌더링됩니다.
 - bootstrap.selectedDeviceId: 사용자가 사이드바에서 다른 장치를 클릭했을 때.
 - series.loading / series.points: 서버에서 차트 데이터를 가져오기 시작하거나(true), 가져오기가 완료되어 데이터가 들어왔을 때.
 - devLast.loading / devLast.error: 장치의 마지막 상태 정보를 가져오는 과정에서 상태가 변할 때.

3. 질문하신 코드 흐름상 가장 빈번한 리렌더링 시나리오는 이렇습니다:
 - 사용자가 탭을 클릭함 (setTab 실행)
 - tab 상태 변경으로 App 리렌더링 (1차)
 - tab이 바뀌었으니 useSeries 훅 안의 activeArgs가 새로 계산됨.
 - activeArgs 변화를 감지한 useEffect가 서버에 데이터를 요청함.
 - 데이터를 가져오기 시작하면서 series.loading이 true로 바뀜.
 - series.loading이 바뀌었으므로 App 리렌더링 (2차 - "로딩 중..." 표시)
 - 서버 응답 도착 후 series.points가 채워짐.
 - 데이터가 바뀌었으므로 App 리렌더링 (3차 - "차트 그래프" 표시)
======================================================================================
훅을 구독한다?
여기서 "구독(Subscribe)한다"는 말은 리액트에서 매우 중요한 개념인데, 아주 쉽게 풀어서 설명해 드릴게요.

1. "구독한다"의 진짜 의미
 리액트에서 훅을 구독한다는 것은 "그 훅 안에서 일어나는 상태 변화를 실시간으로 감시하고, 변화가 생기면 나(부모 컴포넌트)도 같이 화면을 다시 그리겠다"는 약속입니다.
  - useDeviceLast 내부에는 아마 useState나 useEffect가 들어있을 거예요.
  - 만약 서버에서 데이터를 가져와서 훅 내부의 loading 상태가 true에서 false로 바뀌면?
  - 그 훅을 사용(구독)하고 있는 App 컴포넌트에게 리액트가 신호를 보냅니다: "야! 네가 쓰는 devLast 훅 안에 데이터가 바뀌었어. 너도 화면 다시 그려!"

2. 왜 "구독"이라는 표현을 쓸까요? (신문 구독 비유)
 훅 (useDeviceLast): 신문사입니다. 매일 새로운 정보(데이터)를 발행합니다.
  - 컴포넌트 (App): 독자입니다. 신문을 구독 신청했습니다.
  - 작동 원리: 신문사에 새로운 소식(데이터 변경)이 들어오면, 구독 신청을 한 모든 독자(App)의 집 대문 앞에 신문이 배달됩니다. 독자는 새 신문을 읽고 자기 생각을 바꿉니다(리렌더링).

ex)
// 1. bootstrap 훅 구독
const bootstrap = useBootstrap(); 

// 2. devLast 훅 구독 (bootstrap의 선택된 ID를 재료로 사용)
const devLast = useDeviceLast(bootstrap.selectedDeviceId);

이 두 줄 사이에는 놀라운 연쇄 반응이 숨어 있습니다.
 - 사용자가 사이드바에서 장치를 바꿉니다.
 - bootstrap 훅 내부의 selectedDeviceId가 변합니다.
 - bootstrap을 구독하던 App이 리렌더링됩니다.
 - App이 다시 실행되면서 useDeviceLast에게 새로운 id를 넘겨줍니다.
 - useDeviceLast 훅도 내부적으로 새로운 데이터를 가져오기 위해 움직이고, 결과가 나오면 App을 한 번 더 리렌더링시킵니다.

4. 만약 구독하지 않는다면? (비교)
 일반적인 함수와 비교해보면 차이가 명확합니다.
  1) 일반 함수 (구독 X): const data = getStaticData();
   - 이 함수 안의 값이 나중에 바뀐다고 해서 App이 다시 그려지지는 않습니다. 그냥 한 번 부르고 끝입니다.
  2) 리액트 훅 (구독 O): const data = useSomething();
   - 이 훅은 리액트의 상태 시스템에 연결되어 있어서, 내부의 useState가 변하면 연결된 모든 컴포넌트를 깨웁니다.

use로 시작하는 함수(훅)를 호출하여 그 결과값을 변수에 담는 행위 자체가 "나 이 훅을 구독할게!"라는 선언입니다.






======================================================================================
======================================================================================
======================================================================================
